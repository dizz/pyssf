.. 
   Copyright (C) 2010 Platform Computing
   
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.
   
   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
   

The pyrest package
==================

This package implements a generic RESTful interface. It can be used for
all kinds of operations. For now it supports Job submission.

It consist of the following modules:
 * **service** - This is the basic implementation of the RESTful service.
 * **resource_model** - The resource model.
 * **backends** - Backends are used to trigger actually operations.
 * **rendering_parsers** - Parsers which traverse between the data on the wire
   and the resource model.

.. note::
    When using the pyrest module for other stuff then job submission you need
    to create a new **resource** kind and update the rendering parsers. 

.. note::
    Currently pyrest does not handle the scheme given to links and categories.

The pyrest package follows the principals described in [OCCI]_.

Service
-------

Uses [web.py]_ to implement a RESTful service.

Non Persistent Resource Dictionary
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Dictionary which holds resources from the resource model. But when using get
and set it will return the proper HTTP Data needed by the service. This part is
not persistent on failure or restart of the service all resource will be lost.

Persistent Resource Dictionary
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Is not yet implemented.

HTTP Handler
^^^^^^^^^^^^
Handler the basic HTTP CRUD operations. It implements the logic when a resource
is created, updated or destroyed.

Resource Handler
^^^^^^^^^^^^^^^^
Is derived form the HTTP Handler and has some convenient routines to update the
resources in the Resource Dictionary.

Rendering Parsers
-----------------

The HTTP Header Parser
^^^^^^^^^^^^^^^^^^^^^^
Is derived from Parser. Does in general nothing more then parsing the HTTP
header and look for attributes, links and categories

.. note::
    If something is going to fail is is most probably in this class. It is not
    XML and parsing strings from the header and fill them into data structures
    can lead to issues. Still this part is reasonably tested.

Backends
--------
The backends actually trigger operations and map the HTTP/RESTful resource to
something else.

Job Handler
^^^^^^^^^^^
This Handler is capable of submitting jobs using the pydrmaa package. Creation
of the resources should be done with the following category:

    ========  ============================
      Term      Scheme                    
    ========  ============================
    job       "http://purl.org/occi/kind#"
    ========  ============================

Currently the following attributes are supported:

    =========================  ======================  ===========
      Attribute                Description             Example    
    =========================  ======================  ===========
    occi.drmaa.remote_command  Path to Job Executable  /bin/sleep 
    occi.drmaa.args            Arguments               "100"      
    occi.drmaa.job_id          Id of the job in DRM    123        
                               (immutable)                        
    =========================  ======================  ===========

Also the following links/actions can be used to manipulate the job:

    ===================  ===============================
      Link                 Description                  
    ===================  ===============================
    <id>;terminate       Terminate a running job        
    ===================  ===============================

Using the Service
-----------------
You can easily start the service using the following command::

    python service.py

This will start the service listening on the default post 8080. For testing
and development purposes this will do. This will start the internal web server
coming along with web.py. If you plan to deploy the service to others read the
documentation provide in the web.py documentation [DOC]_.

.. note::
    If you want the service to run on another port simple provide the port
    number as a command line parameter.

Now you can access the RESTful service from basically everywhere using anything
. For example you can use your web browser or use the python httplib2 package.
Other programming languages have similar libraries: libcurl for C,
URLConnection for Java, etc. This is transparent to the user and no
knowledge/API/properitary interface to the underlying systems needs to be
provided/used.

A simple python program to submit a job would look like::

    import httplib2
    h = httplib2.Http()
    
    # create HTTP headers with the right category (mandatory field ) and attributes
    heads = {'Category': 'job;scheme="http://purl.org/occi/kind#";label="Job Resource"', 
             'occi.drmaa.remote_command': '/bin/sleep', 'occi.drmaa.args': '10'}
    response = h.request('http://localhost:8080/','POST', headers=heads)
    
    # get the URL of the newly created resource...
    url = str(response)[str(response).find('location') + 12:]
    url = 'http://localhost:8080' + url[:url.find(',') - 1]
    
    # and delete it
    h.request(url,'DELETE')

Writing your own service using pyrest
--------------------------------------
By default the pyrest module supports job submission. But it can easily be
extended to offer any kind of service.

The following code demonstrates howto write your own backend and use the
RESTful interface provided by pyrest::

    from pyrest.service import ResourceHandler
    import web
    
    # 
    # Configures web.py and tells him which handlers should listen to which 
    # entry-point.
    # 
    urls = ('/(.*)', 'ResourceHandler')
    
    # 
    # Turns debugging on of off - Default is False (off).
    # 
    web.config.debug = False
    
    # 
    # When using the build-in webserver of the web.py framework there is no need to
    # change the following line. If the service is deployed in Apache using the
    # mod_wsgi use the second line. Do not change the name of the attribute. Apache
    # mod_wsgi will assume it is named application (lowercase).
    # 
    application = web.application(urls, globals())
    #application = web.application(urls, globals()).wsgifunc()
    
    # 
    # When using the build-in webserver with SSL enabled uncomment the following
    # lines
    # 
    #from web.wsgiserver import CherryPyWSGIServer
    #CherryPyWSGIServer.ssl_certificate = "<path to CA>/newcert.pem"
    #CherryPyWSGIServer.ssl_private_key = "<path to CA>/newkey.pem"
    
    # 
    # Tells the service tells the ResourceHandler which Storage, Backend and which
    # Parser it should use.
    #
    #from <module> import <class>
    #
    # define storage
    #ResourceHandler.resources = MyStorage()
    #
    # define parser
    #MyStorage.parser = MyParser()
    #
    # define a backend
    #ResourceHandler.backend = MyHandler()
    
    if __name__ == "__main__":
        """
        Finally run the application.
        """
        application.run()

This code demonstrates how flexible the environment is. You can easily use the
pyrest package to create a service which provides a IaaS, a PaaS or a SaaS. You
can overwrite the Parser, the backend and the storage used.

Deploy the service in a PKI secured environment
-----------------------------------------------
If you want to deploy the service in a PKI (X509 certificates) secured
environment you'll need to install Apache2. Also the mod-wsgi module is needed.

.. note::
    On an Ubuntu server system the following command will do: **sudo apt-get
    install apache2 libapache2-mod-wsgi**

Next the ssl engine needs to activated for Apache2. To do so add the according
link in the */etc/apache2/mods-enabled* directory.

To setup the service to run on port 21 add the following virtual host to your
Apache configuration. Add a file to */etc/apache2/sites-available/* directory
and set a link to it in the */etc/apache2/sites-enabled* directory.

Add the following content to the file and edit the paths accordingly::

    WSGIPythonPath <python path>
    
    Listen 81
    NameVirtualHost *:81
    <VirtualHost *:81>
        ServerAdmin root@localhost
        ServerName localhost

        SSLEngine on
        SSLCertificateFile <path to cert>/newcert.pem
        SSLCertificateKeyFile<path to cert>/newkey.pem
        SSLCACertificateFile <path to cert>/cacert.pem
        SSLVerifyClient require
        SSLVerifyDepth 2

        SSLOptions +StdEnvVars

        WSGIScriptAlias / /<path to your service>/run.py

        ErrorLog /var/log/apache2/service.error.log
        CustomLog /var/log/apache2/service.log common
    </VirtualHost>

.. note::
    Normally the Python Path of the application to the destination folder after
    a *python setup.py build* run in the root directory of SSF.

When using pydrmaa with LSF
^^^^^^^^^^^^^^^^^^^^^^^^^^^
To setup LSF in in such an environment you need to edit 
*/etc/ld.so.conf.d/lsf.conf* and add the value of the $LSF_LIBDIR environment
variable to this file. Finally run the **ldconfig** command.

In the next step you need to symbolically link lsf.conf to /etc/lsf.conf.
Therefore do a **ln -s <path to lsf>/conf/lsf.conf /etc/**

Some variables need to be added to the lsf.conf file::

    LSF_BINDIR=<path to lsf>/7.0/linux2.6-glibc2.3-x86_64/bin
    LSF_ENVDIR=<path to lsf>/conf
    LSF_LIBDIR=<path to lsf>/7.0/linux2.6-glibc2.3-x86_64/lib
    LSF_SERVERDIR=<path to lsf>/7.0/linux2.6-glibc2.3-x86_64/etc

.. note::
    MAke sure that you update the paths according to the platform architecture
    you run.

Setup a simple CA
^^^^^^^^^^^^^^^^^
To setup an simple CA for managing the X509 certificates do the following::

    /usr/lib/ssl/misc/CA.pl -newca
    
    # create a server certificate
    /usr/lib/ssl/misc/CA.pl -newreq
    /usr/lib/ssl/misc/CA.pl -sign
    mkdir server && mv new* server/
    # (optional) remove pw from key - so apache can startup without asking pw
    cd server
    mv newkey.pem newkey.pem.orig
    openssl rsa -in newkey.pem.orig -out newkey.pem
    
    # create a user certificate
    /usr/lib/ssl/misc/CA.pl -newreq
    /usr/lib/ssl/misc/CA.pl -sign
    mkdir user1 && mv new* user1/

A simple client using the previous described setup
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
This is a simple client using the httplib library::

    import httplib
    
    KEYFILE = '<path to key>/newkey.pem'
    CERTFILE = '<path to cert>/newcert.pem'
    heads = {'Category': 'job;scheme="http://purl.org/occi/kind#"',
         'occi.drmaa.remote_command':'/bin/sleep',
         'occi.drmaa.args':'10'}
    
    conn = httplib.HTTPSConnection('localhost', 81, key_file = KEYFILE,
    cert_file = CERTFILE)
    
    conn.request("POST", "/", headers = heads)
    r1 = conn.getresponse()
    url = r1.getheader('Location')
    print r1.status, r1.reason, r1.getheader('Location'), r1.read()
    
    conn.request("GET", url)
    r2 = conn.getresponse()
    print r2.status, r2.reason, r2.getheaders(), r2.read()
    
    conn.close()

.. [OCCI] OCCI website - http://www.occi-wg.org
.. [web.py] web.py website - http://webpy.org
.. [DOC] web.py website - setup - http://webpy.org/recommended_setup
