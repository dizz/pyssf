.. 
   Copyright (C) 2010 Platform Computing
   
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.
   
   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
   

The pyrest package
==================

The pyrest package can be used to given any given kind of application a remote
RESTful interface. 

.. image:: images/pyrest.png
   :alt: pyREST setup

While following the principals in [OCCI]_ it is very easy to use for remote
clients. PyREST gives your application a modern RESTful interface an will
manage the protocol and the resources. Security mechanisms and examples of how
to use the services are described. All which needs to be done to give your
Application a RESTful interface is to write a simple backend for your system.

Structure of the pyrest package
-------------------------------
The following sections give an overview of the structure of the pyrest module.

Service
^^^^^^^
Uses [web.py]_ to implement a RESTful service. The following classes exist:

 * Non Persistent Resource Dictionary - Dictionary which holds resources from 
   the resource model. But when using get and set it will return the proper 
   HTTP Data needed by the service. This part is not persistent on failure or
   restart of the service all resource will be lost.
 * Persistent Resource Dictionary - Is not yet implemented.
 * HTTP Handler - Handler the basic HTTP CRUD operations. It implements the
   logic when a resource is created, updated or destroyed.
 * Resource Handler - Is derived form the HTTP Handler and has some convenient
   routines to update the resources in the Resource Dictionary.

Rendering Parsers
^^^^^^^^^^^^^^^^^
Parsers map the information in the HTTP request to the resoucer model and back.
An abstract Parser class describes the methods it needs. Right now the
following Parser is implemented:

 * The HTTP Header Parser - Is derived from Parser. Does in general nothing
   more than parsing the HTTP header and look for attributes, links and
   categories.

.. note::
    If something is going to fail is is most probably in this class. It is not
    XML and parsing strings from the header and fill them into data structures
    can lead to issues. Still this part is reasonably tested.

Backends
^^^^^^^^
The backends actually trigger operations and map the HTTP/RESTful resource to
something else (like Virtual Machines or Jobs in a Cluster). The following
backend is implemented:

 * Job Handler - This Handler is capable of submitting jobs using the pydrmaa
   package. Creation of the resources should be done with the following
   category:

    ========  =======================================
      Term      Scheme                               
    ========  =======================================
    job       "http://schemas.ogf.org/occi/resource#"
    ========  =======================================

   Currently the following attributes are supported:

    =========================  ======================  ===========
      Attribute                Description             Example    
    =========================  ======================  ===========
    occi.drmaa.remote_command  Path to Job Executable  /bin/sleep 
    occi.drmaa.args            Arguments               "100"      
    occi.drmaa.job_id          Id of the job in DRM    123        
                               (immutable)                        
    =========================  ======================  ===========

   Also the following links/actions can be used to manipulate the job:

    ===================  ===============================
      Link                 Description                  
    ===================  ===============================
    <id>;terminate       Terminate a running job        
    ===================  ===============================

Writing your own service using pyrest
--------------------------------------
By default the pyrest module supports job submission. But it can easily be
extended to offer any kind of service.

The following code demonstrates howto write your own backend and use the
RESTful interface provided by pyrest::

    from pyrest.service import ResourceHandler
    import web
    
    # 
    # Configures web.py and tells him which handlers should listen to which 
    # entry-point.
    # 
    urls = ('/(.*)', 'ResourceHandler')
    
    # 
    # Turns debugging on of off - Default is False (off).
    # 
    web.config.debug = False
    
    # 
    # When using the build-in webserver of the web.py framework there is no need to
    # change the following line. If the service is deployed in Apache using the
    # mod_wsgi use the second line. Do not change the name of the attribute. Apache
    # mod_wsgi will assume it is named application (lowercase).
    # 
    application = web.application(urls, globals())
    #application = web.application(urls, globals()).wsgifunc()
    
    # 
    # When using the build-in webserver with SSL enabled uncomment the following
    # lines
    # 
    #from web.wsgiserver import CherryPyWSGIServer
    #CherryPyWSGIServer.ssl_certificate = "<path to CA>/newcert.pem"
    #CherryPyWSGIServer.ssl_private_key = "<path to CA>/newkey.pem"
    
    # 
    # Tells the service tells the ResourceHandler which Storage, Backend and which
    # Parser it should use.
    #
    #from <module> import <class>
    #
    # define storage
    #ResourceHandler.resources = MyStorage()
    #
    # define parser
    #MyStorage.parser = MyParser()
    #
    # define a backend
    #ResourceHandler.backend = MyHandler()
    
    if __name__ == "__main__":
        """
        Finally run the application.
        """
        application.run()

This code demonstrates how flexible the environment is. You can easily use the
pyrest package to create a service which provides a IaaS, a PaaS or a SaaS. You
can overwrite the Parser, the backend and the storage used.

.. note::
    If you want the service to run on another port simple provide the port
    number as a command line parameter.

If you plan to deploy the service to others read the documentation provide in
the web.py documentation [DOC]_.

Deploy the service in a PKI secured environment
-----------------------------------------------
If you want to deploy the service in a PKI (X509 certificates) secured
environment you'll need to install Apache2. Also the mod-wsgi module is needed.

.. note::
    On an Ubuntu server system the following command will do: **sudo apt-get
    install apache2 libapache2-mod-wsgi**

Next the ssl engine needs to activated for Apache2. To do so add the according
link in the */etc/apache2/mods-enabled* directory.

To setup the service to run on port 21 add the following virtual host to your
Apache configuration. Add a file to */etc/apache2/sites-available/* directory
and set a link to it in the */etc/apache2/sites-enabled* directory.

Add the following content to the file and edit the paths accordingly::

    WSGIPythonPath <python path>
    
    Listen 81
    NameVirtualHost *:81
    <VirtualHost *:81>
        ServerAdmin root@localhost
        ServerName localhost

        SSLEngine on
        SSLCertificateFile <path to cert>/newcert.pem
        SSLCertificateKeyFile<path to cert>/newkey.pem
        SSLCACertificateFile <path to cert>/cacert.pem
        SSLVerifyClient require
        SSLVerifyDepth 2

        SSLOptions +StdEnvVars

        WSGIScriptAlias / /<path to your service>/run.py

        ErrorLog /var/log/apache2/service.error.log
        CustomLog /var/log/apache2/service.log common
    </VirtualHost>

.. note::
    Normally the Python Path should be set to the ouput folder of a *python
    setup.py build* or *python setup.py install* run in the root directory of
    SSF.

Setup a simple CA
^^^^^^^^^^^^^^^^^
To setup an simple CA for managing the X509 certificates do the following::

    /usr/lib/ssl/misc/CA.pl -newca
    
    # create a server certificate
    /usr/lib/ssl/misc/CA.pl -newreq
    /usr/lib/ssl/misc/CA.pl -sign
    mkdir server && mv new* server/
    # (optional) remove pw from key - so apache can startup without asking pw
    cd server
    mv newkey.pem newkey.pem.orig
    openssl rsa -in newkey.pem.orig -out newkey.pem
    
    # create a user certificate
    /usr/lib/ssl/misc/CA.pl -newreq
    /usr/lib/ssl/misc/CA.pl -sign
    mkdir user1 && mv new* user1/

.. [OCCI] OCCI website - http://www.occi-wg.org
.. [web.py] web.py website - http://webpy.org
.. [DOC] web.py website - setup - http://webpy.org/recommended_setup
