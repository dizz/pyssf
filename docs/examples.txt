.. 
   Copyright (C) 2010 Platform Computing
   
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.
   
   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
   

Examples of how to use SSF
==========================
The following examples demonstrate how the SSF modules can be used individually
or in conjunction. These examples just demonstrate how SSF can be used in
different setups. The examples are for demonstration purposes only - they do
not strive to be complete or perfectly pythonic.

To add your own backend and RESTify you application with an OCCI compliant
interface you need to do the following steps:

 * create a backend which is a child of pyrest.backends.Handler
 * define the categories you backend can handle
 * implement the create, retrieve, update, delete and action routines
 * define the application and run it

Using the pyrest module for a Key-Value store
---------------------------------------------
This example gives a first very easy overview of how to use the pyrest package
and write your own backend. The backend will be able to store a Key and a Value
which are associated to URL. It therefore only supports one category.

The backend will be able to support the following category (which is needed for
the handling of resources):

    ========  =======================================
      Term      Scheme                               
    ========  =======================================
    keyvalue  "http://schemas.ogf.org/occi/keyvalue#"
    ========  =======================================

   Currently the following attributes are supported:

    ===================  ===============  ===========
      Attribute            Description      Example  
    ===================  ===============  ===========
    occi.keyvalue.key    The keye         foo        
    occi.keyvalue.value  The value        bar        
    ===================  ===============  ===========
    
Writting a backend which acts as a Key-Value store
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The following core shows the simple Key-Value store backend::

    from pyrest import backends
    from pyrest.backends import Handler
    from pyrest.myexceptions import MissingAttributesException
    from pyrest.resource_model import Category, Resource
    from pyrest.service import ResourceHandler
    
    import web
    
    class KeyValueHandler(Handler):
    
        category = Category()
        category.attributes = ['occi.keyvalue.keq', 'occi.keyvalue.value']
        category.related = [Resource.category]
        category.scheme = 'http://schemas.ogf.org/occi/keyvalue#'
        category.term = 'keyvalue'
        category.title = 'A key-value Resource'
    
        def __init__(self):
            """
            Registers the categories this backend can handle.
            """
            backends.register([self.category], self)
    
        def create(self, resource):
            if self.category in resource.categories:
                if not 'occi.keyvalue.keq' in resource.attributes and not 'occi.keyvalue.value' in resource.attributes:
                    raise MissingAttributesException('Missing key and value attributes')
            else:
                pass
    
        def retrieve(self, resource):
            if self.category in resource.categories:
                pass
            else:
                pass
    
        def update(self, resource, updated_resource):
            if self.category in updated_resource.categories:
                if not 'occi.keyvalue.keq' in updated_resource.attributes and not 'occi.keyvalue.value' in updated_resource.attributes:
                    raise MissingAttributesException('Missing key and value attributes')
                resource.attributes['occi.keyvalue.key'] = updated_resource.attributes['occi.keyvalue.key']
                resource.attributes['occi.keyvalue.value'] = updated_resource.attributes['occi.keyvalue.value']
            else:
                pass
    
        def delete(self, resource):
            if self.category in resource.categories:
                pass
            else:
                pass
    
        def action(self, resource, action):
            pass
    
    # setup the service
    urls = ('/(.*)', 'ResourceHandler')
    web.config.debug = False
    
    # register the backend
    KeyValueHandler()
    
    # create the app...
    application = web.application(urls, globals())
    
    # run...
    if __name__ == "__main__":
        application.run()

Using the pyrest module for job submission
------------------------------------------
The following sections describe how to use the pyrest package for a scenario in
which jobs are submitted through an RESTful interface.

The example described below will be capabable of handling the following
information: 

   Creation of the resources should be done with the following registered
   category:

    ========  ====================================
      Term      Scheme                            
    ========  ====================================
    job       "http://schemas.ogf.org/occi/drmaa#"
    ========  ====================================

   Currently the following attributes are supported:

    =========================  ======================  ===========
      Attribute                Description             Example    
    =========================  ======================  ===========
    occi.drmaa.remote_command  Path to Job Executable  /bin/sleep 
    occi.drmaa.args            Arguments               "100"      
    occi.drmaa.job_id          Id of the job in DRM    123        
                               (immutable)                        
    =========================  ======================  ===========

   Also the following category for actions are registered:
    
    =========  ===========================================
      Term      Scheme                                    
    =========  ===========================================
    terminate  "http://schemas.ogf.org/occi/drmaa/action#"
    =========  ===========================================

  This results in the following action links:

    =====================  ===============================
      Link                   Description                  
    =====================  ===============================
    <id>;action=terminate  Terminate a running job        
    =====================  ===============================

Writing a backend for job submission
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The following example show the complete setup of a backend and the service
using the pyrest module. It describes the job submission handler- it just shows
how to write your own backend.

The following code shows this by registering two categories and using the
pydrmaa package as a backend::

    from pydrmaa.job import JobFactory
    
    from pyrest import backends
    from pyrest.backends import Handler
    from pyrest.myexceptions import MissingAttributesException, StateException, MissingActionException
    from pyrest.resource_model import Category, Resource, Action
    from pyrest.service import ResourceHandler
    
    import web
    
    # create a backend
    class JobHandler(Handler):
        jobs = {}
    
        category = Category()
        category.attributes = ['occi.drmaa.remote_command', 'occi.drmaa.args',
                               'occi.drmaa.job_id']
        category.related = [Resource.category]
        category.scheme = 'http://schemas.ogf.org/occi/drmaa#'
        category.term = 'job'
        category.title = 'A Job Resource'
    
        terminate_category = Category()
        terminate_category.related = [Action.category]
        terminate_category.scheme = 'http://schemas.ogf.org/occi/drmaa/action#'
        terminate_category.term = 'terminate'
        terminate_category.title = 'Terminate a Job'
    
        def __init__(self):
            """
            Registers the categories this backend can handle.
            """
            backends.register([self.category, self.terminate_category], self)
    
        def create(self, resource):
            if self.category in resource.categories:
                if not 'occi.drmaa.remote_command' in resource.attributes:
                    raise MissingAttributesException('Missing command argument')
    
                command = resource.attributes['occi.drmaa.remote_command']
                if 'occi.drmaa.args' in resource.attributes:
                    args = resource.attributes['occi.drmaa.args'].split(' ')
                else:
                    args = None
                job = JobFactory().create_job(command, args)
    
                # update links & attributes
                action = Action()
                action.categories = [self.terminate_category]
    
                # I can append because not action links could be added previously
                # because parsers take care of that...
                resource.actions.append(action)
                resource.attributes['occi.drmaa.job_id'] = job.job_id
    
                self.jobs[job.job_id] = job
            else:
                pass
    
        def retrieve(self, resource):
            if self.category in resource.categories:
                if not 'occi.drmaa.job_id' in resource.attributes:
                    raise MissingAttributesException('Something is wrong here'
                                                     + ' running job resource'
                                                     + ' should have an id.')
                job = self.jobs[resource.attributes['occi.drmaa.job_id']]
                state = job.get_state()
                resource.attributes['occi.drmaa.job_state'] = state
                if state == 'running':
                    action = Action()
                    action.categories = [self.terminate_category]
                    # drop old links - when running cannot change links!
                    resource.action = [action]
                if state == 'done' or state == 'failed':
                    resource.actions = []
            else:
                pass
    
        def update(self, resource, updated_resource):
            # not allowing the update :-D
            pass
    
        def delete(self, resource):
            if self.category in resource.categories:
                if not 'occi.drmaa.job_id' in resource.attributes:
                    raise MissingAttributesException('Something is wrong here'
                                                     + ' running job resource'
                                                     + ' should have an id.')
                job = self.jobs[resource.attributes['occi.drmaa.job_id']]
                state = job.get_state()
                if state != 'done' and state != 'failed':
                    job.terminate()
                del self.jobs[resource.attributes['occi.drmaa.job_id']]
            else:
                pass
    
        def action(self, resource, action):
            if self.category in resource.categories:
                # update attributes and links if needed and trigger action
                # check if action is in current available actions
                if action in resource.actions:
                    try:
                        job = self.jobs[resource.attributes['occi.drmaa.job_id']]
                    except:
                        raise StateException('Trying to run an action on non'
                                             + 'active resource.')
                    # test which action to trigger and run it...
                    if self.terminate_category in action.categories:
                        job.terminate()
                        resource.actions = []
                    resource.attributes['occi.drmaa.job_state'] = job.get_state()
                else:
                    raise MissingActionException('Non existing action called!')
            else:
                pass
    
    # setup the service
    urls = ('/(.*)', 'ResourceHandler')
    web.config.debug = False
    
    JobHandler()
    
    application = web.application(urls, globals())
    
    # run...
    if __name__ == "__main__":
        application.run()

Configure service without SSL or authentication
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The following code demonstrates how to setup a service in the easiest possible
way using the previously described JobHandler::

    from pyrest import service
    from pyrest.examples.restful_job_submission import JobHandler
    from pyrest.service import ResourceHandler
    import web
    
    # setup the service
    urls = ('/(.*)', 'ResourceHandler')
    web.config.debug = False
    
    JobHandler()
    
    application = web.application(urls, globals())
    
    # run...
    if __name__ == "__main__":
        application.run()

Using pyrest with SSL and basic Authentication
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The following code can be used to realize a RESTful interface for job
submission using the pyrest module. It uses the internal CherryPy web server::

    from pyrest import service, myexceptions
    from pyrest.examples.restful_job_submission import JobHandler
    from pyrest.service import ResourceHandler
    from pyrest.service import SecurityHandler
    import web
    
    # setup the service
    urls = ('/(.*)', 'ResourceHandler')
    web.config.debug = False
    application = web.application(urls, globals())
    
    JobHandler()    
    
    # enable SSL
    from web.wsgiserver import CherryPyWSGIServer
    CherryPyWSGIServer.ssl_certificate = "<path to ca>/newcert.pem"
    CherryPyWSGIServer.ssl_private_key = "<path to ca>/newkey.pem"
    
    # create a very simple security handler
    class SimpleSecurityHandler(SecurityHandler):
        
        def authenticate(self, username, password):
            if username == 'foo' and password == 'bar':
                pass
            else:
                raise myexceptions.SecurityException()
    
    # activate authentication
    service.AUTHENTICATION_ENABLED = True
    service.SECURITY_HANDLER = SimpleSecurityHandler()
    
    # run...
    if __name__ == "__main__":
        application.run()

Using pyrest in a PKI secured environment
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
This example assumes that you have deployed pyrest using mod_wsgi on Apache. To
use pyrest in this setup use the following script (which is configures in your
Apache site configuration)::

    from pyrest import service
    from pyrest.examples.restful_job_submission import JobHandler
    from pyrest.service import ResourceHandler
    import web
    
    # setup the service
    urls = ('/(.*)', 'ResourceHandler')
    web.config.debug = False
    
    JobHandler()
    
    application = web.application(urls, globals()).wsgifunc()

.. note::
    See the slightly different application assigment with the wsgifunc() call
    added. Also note that no security feature need to be enabled, since Apache
    handles those.

A simple job submission client (without SSL or authentication)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now you can access the RESTful service from basically everywhere using anything
. For example you can use your web browser or use the python httplib2 package.
Other programming languages have similar libraries: libcurl for C,
URLConnection for Java, etc. This is transparent to the user and no
knowledge/API/proprietary interface to the underlying systems needs to be
provided/used.

A simple python program to submit a job would look like::

    import httplib2
    h = httplib2.Http()
    
    # create HTTP headers with the right category (mandatory field ) and attributes
    heads = {'Category': 'job;scheme="http://schemas.ogf.org/occi/drmaa#";label="Job Resource"',
             'Attribute': 'occi.drmaa.remote_command=/bin/sleep, occi.drmaa.args=10'}
    response = h.request('http://localhost:8080/','POST', headers=heads)
    
    # get the URL of the newly created resource...
    url = str(response)[str(response).find('location') + 12:]
    url = 'http://localhost:8080' + url[:url.find(',') - 1]
    
    # get the newly created resource
    response = h.request(url,'GET')
    
    # run the terminate action
    terminate_link = str(response)[str(response).find('link') + 9:str(response).find('>')]
    terminate_header = {'Category': 'terminate;scheme="http://schemas.ogf.org/occi/drmaa/action#"'}
    response = h.request('http://localhost:8080' + terminate_link, 'POST', headers=terminate_header)
    
    # delete the resource
    print h.request(url,'DELETE')

A simple job submission client using SSL and basic authentication
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
A simple client which corresponds to the setup described above::

    import httplib
    import base64
    import string
    
    heads = {'Category': 'job;scheme="http://schemas.ogf.org/occi/drmaa#"',
             'Attribute': 'occi.drmaa.remote_command=/bin/sleep, occi.drmaa.args=10',
             'Authorization': 'Basic ' + string.strip(base64.encodestring('foo' + ':' + 'bar')) }
    
    # setup SSL connection
    conn = httplib.HTTPSConnection('localhost', 8080)
    
    # create a resource
    conn.request("POST", "/", headers = heads)
    r1 = conn.getresponse()
    url = r1.getheader('Location')
    print r1.status, r1.reason, r1.getheader('Location'), r1.read()
    
    # and get it
    conn.request("GET", url, headers={'Authorization': 'Basic ' + string.strip(base64.encodestring('foo' + ':' + 'bar'))})
    r2 = conn.getresponse()
    print r2.status, r2.reason, r2.getheaders(), r2.read()
    
    conn.close()

A simple job submission client which uses X590 certificates
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
This is a simple client using the httplib library::

    import httplib
    
    KEYFILE = '<path to key>/newkey.pem'
    CERTFILE = '<path to cert>/newcert.pem'
    heads = {'Category': 'job;scheme="http://schemas.ogf.org/occi/drmaa#"',
             'Attribute': 'occi.drmaa.remote_command=/bin/sleep, occi.drmaa.args=10'}
    
    # create a PKI secured connection
    conn = httplib.HTTPSConnection('localhost', 81, key_file = KEYFILE, cert_file = CERTFILE)
    
    # create a resource
    conn.request("POST", "/", headers = heads)
    r1 = conn.getresponse()
    url = r1.getheader('Location')
    print r1.status, r1.reason, r1.getheader('Location'), r1.read()
    
    # and get the resource
    conn.request("GET", url)
    r2 = conn.getresponse()
    print r2.status, r2.reason, r2.getheaders(), r2.read()
    
    conn.close()

Using the pyrest module as a Cloud interface
--------------------------------------------
The following code examples demonstrates how to configure the ResourceHandler
to use a different backend. The backend described here will uses VirtualBox. So
the pyrest module basically becomes a RESTful Cloud Computing interface for
Virtual Machine management (IaaS).

TBD.
