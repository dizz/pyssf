.. 
   Copyright (C) 2010 Platform Computing
   
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.
   
   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
   

Examples of how to use SSF
==========================
The following examples demonstrate how the SSF modules can be used individually
or in conjunction. These examples just demonstrate how SSF can be used in
different setups. The examples are for demonstration purposes only - they do
not strive to be complete or perfectly pythonic.

Using the pyrest module (job submission)
----------------------------------------
The following sections describe some possible use case setups for the pyrest
module. All use the default ResourceHandler, Storage and Backend and therefore
feature only job submissions.

Using pyrest without SSL or authentication
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The following code demonstrates how to setup pyrest in the easiest possible
way::

    from pyrest import service
    from pyrest.backends import JobHandler
    from pyrest.service import ResourceHandler
    import web
    
    # setup the service
    urls = ('/(.*)', 'ResourceHandler')
    web.config.debug = False
    
    JobHandler()
    
    application = web.application(urls, globals())
    
    # run...
    if __name__ == "__main__":
        application.run()

Using pyrest with SSL and basic Authentication
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The following code can be used to realize a RESTful interface for job
submission using the pyrest module. It uses the internal CherryPy web server::

    from pyrest import service, myexceptions
    from pyrest.backends import JobHandler
    from pyrest.service import ResourceHandler
    from pyrest.service import SecurityHandler
    import web
    
    # setup the service
    urls = ('/(.*)', 'ResourceHandler')
    web.config.debug = False
    application = web.application(urls, globals())
    
    JobHandler()    
    
    # enable SSL
    from web.wsgiserver import CherryPyWSGIServer
    CherryPyWSGIServer.ssl_certificate = "<path to ca>/newcert.pem"
    CherryPyWSGIServer.ssl_private_key = "<path to ca>/newkey.pem"
    
    # create a very simple security handler
    class SimpleSecurityHandler(SecurityHandler):
        
        def authenticate(self, username, password):
            if username == 'foo' and password == 'bar':
                pass
            else:
                raise myexceptions.SecurityException()
    
    # activate authentication
    service.AUTHENTICATION_ENABLED = True
    service.SECURITY_HANDLER = SimpleSecurityHandler()
    
    # run...
    if __name__ == "__main__":
        application.run()

Using pyrest in a PKI secured environment
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
This example assumes that you have deployed pyrest using mod_wsgi on Apache. To
use pyrest in this setup use the following script (which is configures in your
Apache site configuration)::

    from pyrest import service
    from pyrest.backends import JobHandler
    from pyrest.service import ResourceHandler
    import web
    
    # setup the service
    urls = ('/(.*)', 'ResourceHandler')
    web.config.debug = False
    
    JobHandler()
    
    application = web.application(urls, globals()).wsgifunc()

.. note::
    See the slightly different application assigment with the wsgifunc() call
    added. Also note that no security feature need to be enabled, since Apache
    handles those.

Using the pyrest module (own backend)
-------------------------------------
The following example show the complete setup of a backend and the service
using the pyrest module. It describes the job submission handler which is
already include in the pyrest package - it just shows how to write your own
backend.

To add your own backend and RESTify you application with an OCCI complient
interface you need to do the following steps:

 * create a backend which is a child of pyrest.backends.Handler
 * define the categories you backend can handle
 * implement the create, retrieve, update, delete and action routines
 * define the application and run it

The following code shows this::

    from pydrmaa.job import JobFactory
    
    from pyrest import backends
    from pyrest.backends import Handler
    from pyrest.myexceptions import MissingAttributesException, StateException, MissingActionException
    from pyrest.resource_model import Category, Resource, Action
    from pyrest.service import ResourceHandler
    
    import web
    
    # create a backend
    class JobHandler(Handler):
        jobs = {}
    
        category = Category()
        category.attributes = ['occi.drmaa.remote_command', 'occi.drmaa.args',
                               'occi.drmaa.job_id']
        category.related = [Resource.category]
        category.scheme = 'http://schemas.ogf.org/occi/drmaa#'
        category.term = 'job'
        category.title = 'A Job Resource'
    
        terminate_category = Category()
        terminate_category.related = [Action.category]
        terminate_category.scheme = 'http://schemas.ogf.org/occi/drmaa/action#'
        terminate_category.term = 'terminate'
        terminate_category.title = 'Terminate a Job'
    
        def __init__(self):
            """
            Registers the categories this backend can handle.
            """
            backends.register([self.category, self.terminate_category], self)
    
        def create(self, resource):
            if self.category in resource.categories:
                if not 'occi.drmaa.remote_command' in resource.attributes:
                    raise MissingAttributesException('Missing command argument')
    
                command = resource.attributes['occi.drmaa.remote_command']
                if 'occi.drmaa.args' in resource.attributes:
                    args = resource.attributes['occi.drmaa.args'].split(' ')
                else:
                    args = None
                job = JobFactory().create_job(command, args)
    
                # update links & attributes
                action = Action()
                action.categories = [self.terminate_category]
    
                # I can append because not action links could be added previously
                # because parsers take care of that...
                resource.actions.append(action)
                resource.attributes['occi.drmaa.job_id'] = job.job_id
    
                self.jobs[job.job_id] = job
            else:
                pass
    
        def retrieve(self, resource):
            if self.category in resource.categories:
                if not 'occi.drmaa.job_id' in resource.attributes:
                    raise MissingAttributesException('Something is wrong here'
                                                     + ' running job resource'
                                                     + ' should have an id.')
                job = self.jobs[resource.attributes['occi.drmaa.job_id']]
                state = job.get_state()
                resource.attributes['occi.drmaa.job_state'] = state
                if state == 'running':
                    action = Action()
                    action.categories = [self.terminate_category]
                    # drop old links - when running cannot change links!
                    resource.action = [action]
                if state == 'done' or state == 'failed':
                    resource.actions = []
            else:
                pass
    
        def update(self, resource):
            # not allowing the update :-D
            pass
    
        def delete(self, resource):
            if self.category in resource.categories:
                if not 'occi.drmaa.job_id' in resource.attributes:
                    raise MissingAttributesException('Something is wrong here'
                                                     + ' running job resource'
                                                     + ' should have an id.')
                job = self.jobs[resource.attributes['occi.drmaa.job_id']]
                state = job.get_state()
                if state != 'done' and state != 'failed':
                    job.terminate()
                del self.jobs[resource.attributes['occi.drmaa.job_id']]
            else:
                pass
    
        def action(self, resource, action):
            if self.category in resource.categories:
                # update attributes and links if needed and trigger action
                # check if action is in current available actions
                if action in resource.actions:
                    try:
                        job = self.jobs[resource.attributes['occi.drmaa.job_id']]
                    except:
                        raise StateException('Trying to run an action on non'
                                             + 'active resource.')
                    # test which action to trigger and run it...
                    if self.terminate_category in action.categories:
                        job.terminate()
                        resource.actions = []
                    resource.attributes['occi.drmaa.job_state'] = job.get_state()
                else:
                    raise MissingActionException('Non existing action called!')
            else:
                pass
    
    # setup the service
    urls = ('/(.*)', 'ResourceHandler')
    web.config.debug = False
    
    JobHandler()
    
    application = web.application(urls, globals())
    
    # run...
    if __name__ == "__main__":
        application.run()

Clients for pyrest (job submission)
-----------------------------------

A simple pyrest client (without SSL or authentication)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now you can access the RESTful service from basically everywhere using anything
. For example you can use your web browser or use the python httplib2 package.
Other programming languages have similar libraries: libcurl for C,
URLConnection for Java, etc. This is transparent to the user and no
knowledge/API/proprietary interface to the underlying systems needs to be
provided/used.

A simple python program to submit a job would look like::

    import httplib2
    h = httplib2.Http()
    
    # create HTTP headers with the right category (mandatory field ) and attributes
    heads = {'Category': 'job;scheme="http://schemas.ogf.org/occi/drmaa#";label="Job Resource"',
             'Attribute': 'occi.drmaa.remote_command=/bin/sleep, occi.drmaa.args=10'}
    response = h.request('http://localhost:8080/','POST', headers=heads)
    
    # get the URL of the newly created resource...
    url = str(response)[str(response).find('location') + 12:]
    url = 'http://localhost:8080' + url[:url.find(',') - 1]
    
    # get the newly created resource
    response = h.request(url,'GET')
    
    # run the terminate action
    terminate_link = str(response)[str(response).find('link') + 9:str(response).find('>')]
    terminate_header = {'Category': 'terminate;scheme="http://schemas.ogf.org/occi/drmaa/action#"'}
    response = h.request('http://localhost:8080' + terminate_link, 'POST', headers=terminate_header)
    
    # delete the resource
    print h.request(url,'DELETE')

A pyrest client using SSL and basic authentication
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
A simple client which corresponds to the setup described above::

    import httplib
    import base64
    import string
    
    heads = {'Category': 'job;scheme="http://schemas.ogf.org/occi/drmaa#"',
             'Attribute': 'occi.drmaa.remote_command=/bin/sleep, occi.drmaa.args=10',
             'Authorization': 'Basic ' + string.strip(base64.encodestring('foo' + ':' + 'bar')) }
    
    # setup SSL connection
    conn = httplib.HTTPSConnection('localhost', 8080)
    
    # create a resource
    conn.request("POST", "/", headers = heads)
    r1 = conn.getresponse()
    url = r1.getheader('Location')
    print r1.status, r1.reason, r1.getheader('Location'), r1.read()
    
    # and get it
    conn.request("GET", url, headers={'Authorization': 'Basic ' + string.strip(base64.encodestring('foo' + ':' + 'bar'))})
    r2 = conn.getresponse()
    print r2.status, r2.reason, r2.getheaders(), r2.read()
    
    conn.close()

A pyrest client which uses X590 certificates
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
This is a simple client using the httplib library::

    import httplib
    
    KEYFILE = '<path to key>/newkey.pem'
    CERTFILE = '<path to cert>/newcert.pem'
    heads = {'Category': 'job;scheme="http://schemas.ogf.org/occi/drmaa#"',
             'Attribute': 'occi.drmaa.remote_command=/bin/sleep, occi.drmaa.args=10'}
    
    # create a PKI secured connection
    conn = httplib.HTTPSConnection('localhost', 81, key_file = KEYFILE, cert_file = CERTFILE)
    
    # create a resource
    conn.request("POST", "/", headers = heads)
    r1 = conn.getresponse()
    url = r1.getheader('Location')
    print r1.status, r1.reason, r1.getheader('Location'), r1.read()
    
    # and get the resource
    conn.request("GET", url)
    r2 = conn.getresponse()
    print r2.status, r2.reason, r2.getheaders(), r2.read()
    
    conn.close()

Using the pyrest module (customized backend)
--------------------------------------------
The following code examples demonstrates how to configure the ResourceHandler
to use a different backend. The backend described here will uses VirtualBox. So
the pyrest module basically becomes a RESTful Cloud Computing interface for
Virtual Machine management (IaaS).
